# Feb 27 2018

### Inverted Page Tables
- Index on frame number, not virtual address.
![](/assets/Screen Shot 2018-03-14 at 2.47.16 PM.png)

### Translation Lookaside Buffer
- Each virtual memory access can cause two physical memory addresses
    1. Fetch the page table entry
    2. Fetch the data
- **Fix:** add caches
![](/assets/Screen Shot 2018-03-14 at 2.50.12 PM.png)

#### Steps
1. CPU checks TLB (Translation Lookaside Buffer)
2. Check page table entry in TLB?
    - If Yes, CPU generates physical address
    - If No, access page table and check if page is in main memory
        - If page is not found, raise page fault, read page from disk and transfer it to main memory 
        - If page is found, CPU generates physical address, update the TLB
        
### Page size
- Small Page Size
    - less internal fragmentation
    - more pages per process => larger page tables => large portion of page tables in virtual memory
    - more pages benefits from principal of locality => page faults low
- Large Page Size
    - secondary memory transfers larger blocks of data better
    - pages tend to be farther away from recent reference => higher page faults
    
OS Designer needs to make 3 decisions:
1. Does the system need virtual memory?
2. Paging, segmentation, or both?
3. Which algorithms for memory management?
    - Fetch policy
    - Placement policy
    - Replacement policy
    - Cleaning policy
    - Load control
